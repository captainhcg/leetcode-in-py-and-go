# Leetcode in PY and GO
A shelf of my solutions of Leetcode Algorithms Programs in both Python Golang

* 3: one-loop solution; start index
* 5: handle "aaaaaaa" by `expand` 
* 11: know what it is talking about
* 24: beautiful recursive solution
* 25: a sieve algo
* 29: overflow; both-negative
* 31: just do it again
* 40: pass last selected index
* 51 & 52: 8 queens - checking diagonal smart!!!
* 55: it is a easy question but I made too many mistakes. Shall do it again
* 59: spiral magic: zip(*A[::-1])
* 61: create a circle link
* 75: pay attention to the ptrs, do it again if you have time
* 88: just do it again
* 89: just know the shitty trick of graycode
* 90: use closure and last idx, do it again
* 91: just do it again
* 93: '010.01.01.010'
* 114: do it in post-travel
* 116: connect 2rd level
* 128: look left & look right
* 134: think about it, gas station
* 139: pay attentation to index, better do it again
* 146: LRU, OrderedDict. popitem(last=True), pop()
* 150: -1/5 = -1
* 152: global_max, current_max, current_min
* 160: know the trick
* 162: find local peak. Should do it again
* 164: 1.0.0
* 168: n, idx = divmod(n-1, 26)
* 172: know the trick
* 173: solved it by myself in one pass, but still read it if I have time
* 179: pay attentation to "00" and "0"
* 189: k = k % len(nums)
* 198: The second room
* 201: Kerninghan Algorithm: n & (n-1)
* 207: TP sort but not really sort, do it again
* 215: quick-select, partition, do it again
* 222: know what Complete Tree is and compare the depth
* 236: a spendid way to get the path of p and q, do it again
* 238: Index
* 240: know the splendid trick, top-right or left-bottom
* 241: solved it by myself, but still read it if I have time
* 275: just do it again
* 279: DP trick: i - n*n
* 260: bit := res & (-res)
* 300: know the splendid nlog(n) solution
* 309: know the splendid DP trick
* 318: compare mask and multiply mask
* 319: know the trick
* 328: clean up tails
* 331: d##
* 332: stupid itinerary problem
* 334: know the trick and do it again
* 347: Bucket Sort
* 354: NlogN solution, bisect_left
* 355: heapq.merge; itertools.islice
* 357: 0; The helper function
* 367: 1 + 2 + 3 + ... & Newton's method
* 373: It is ok to use n*n solution, know heapq
* 376: it is actualyl counting the segments (+1), not the numbers
* 377: DP trick, do it again
