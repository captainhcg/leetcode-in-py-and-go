# Leetcode in PY and GO
A shelf of my solutions of Leetcode Algorithms Programs in both Python Golang

* 3: one-loop solution; start index
* 5: handle "aaaaaaa" by `expand` 
* 11: know what it is talking about
* 23: merge k, solved it in one pass, but check it out again
* 24: beautiful recursive solution
* 25: a sieve algo
* 29: overflow; both-negative
* 31: just do it again
* 33: compare mid value with edges, not target with edges
* 40: pass last selected index
* 42: just reminder: blocks - bins
* 51 & 52: 8 queens - checking diagonal smart!!!
* 55: it is a easy question but I made too many mistakes. Shall do it again
* 59: spiral magic: zip(*A[::-1])
* 60: pay attentation to base, C(n-1) not C(n)
* 61: create a circle link
* 75: pay attention to the ptrs, do it again if you have time
* 88: just do it again
* 89: just know the shitty trick of graycode
* 90: use closure and last idx, do it again
* 91: just do it again
* 93: '010.01.01.010'
* 114: do it in post-travel
* 116: connect 2rd level
* 128: look left & look right
* 134: think about it, gas station
* 139: pay attentation to index, better do it again
* 146: LRU, OrderedDict. popitem(last=True), pop()
* 147: keep tracking the tail node to speed up
* 149: do not need a global dict, just a fresh dict in each loop
* 150: -1/5 = -1
* 152: global_max, current_max, current_min
* 157: read4, know what it is talking about
* 160: know the trick
* 162: find local peak. Should do it again
* 164: 1.0.0
* 168: n, idx = divmod(n-1, 26)
* 170: simple but made a lot of mistakes. do it again
* 172: know the trick
* 173: solved it by myself in one pass, but still read it if I have time
* 179: pay attentation to "00" and "0"
* 189: k = k % len(nums)
* 198: The second room
* 201: Kerninghan Algorithm: n & (n-1)
* 207: TP sort but not really sort, do it again
* 215: quick-select, partition, do it again
* 220: **very tough problem with bucket, do it again**
* 222: know what Complete Tree is and compare the depth
* 227: there is a one-pass solution and store `op` as `+` before the loop
* 236: a spendid way to get the path of p and q, do it again
* 238: Index
* 240: know the splendid trick, top-right or left-bottom
* 241: solved it by myself, but still read it if I have time
* 253: super smart one pass solution, pay attentation to (1, 2), (2, 3)
* 269: crazy. zip, topo sort, ['a'] and ['ab', 'a']
* 270: simple but made many stupid mistakes, do it again
* 275: just do it again
* 279: DP trick: i - n*n
* 280: know the one pass trick or wiggle sort
* 260: bit := res & (-res)
* 294: brute force with cache
* 295: shall store minus value in maxheap; heapq.heappushpop
* 300: know the splendid nlog(n) solution
* 309: know the splendid DP trick
* 318: compare mask and multiply mask
* 319: know the trick
* 322: coins change, both BFS and DP, BFS is faster
* 328: clean up tails
* 331: d##
* 332: stupid itinerary problem
* 334: know the trick and do it again
* 347: Bucket Sort
* 354: NlogN solution, bisect_left
* 355: heapq.merge; itertools.islice
* 357: 0; The helper function
* 364: pass int sum to deeper level and return it back
* 367: 1 + 2 + 3 + ... & Newton's method
* 373: It is ok to use n*n solution, know heapq
* 376: it is actualyl counting the segments (+1), not the numbers
* 377: DP trick, do it again
